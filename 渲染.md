OSG开放了所有的功能模块。因此用户程序完全可以使用最底层的OSG功能来执行渲染操作。假设有用户希望能够完全自主地控制场景图形的渲染，那么也可以按照下面的步骤编写应用程序的代码。
- 设计自己的视角管理代码，以改变 OpenGL 的模型-视图（model-view） 矩阵。
- 创建用户窗口和 OpenGL上下文，并将它们激活。如果有需要的话，用户也可以自行编写管理多窗口和多个设备上下文的代码。
- 如果用户程序需要使用分页数据库（paged  database），那么可以使用osgDB:: DatabasePager 类。
- 可以将osgUtil::UpdateVisitor，osgUtil::CullVisitor和osgUtil::RenderStage对象实例化，以实现场景的更新，拣选和绘制遍历。如果用户希望获得更多的控制权，则可以自己编写类来实现以上遍历的特性。
- 编写主循环代码来处理操作系统系统返回的事件。并且调用自己的视角观察代码来更新模型-视图矩阵。
- 在渲染一帧之前先要调用glClear()。渲染时要依次执行场景更新，拣选和绘制遍历，最后交换缓存数据。
- 如果用户程序或者运行该程序的软、硬件平台需要立体化渲染（stereo
rendering）或者多通道渲染（multipipe rendering）功能的支持，则可以自行编写额外的代码。
- 最后，请依照平台无关性的要求来编写所有的代码，这样你的代码才可以在所有的目标平台上运行通过。

上述的步骤并非不可行，但是十分繁琐和浪费时间。并且，由于程序使用了底层的接口，当OSG的后继版本修改了这些底层函数之后，用户的程序将不再 和 OSG 的最新版本兼容。

幸运的是，OSG 每时每刻都在进化，它不断的将一些更为简捷的渲染函数合并到现有版本中，为用户程序提供更多更强大的渲染方案。用户使用OSG编写程序时，往往可以利用以下这些工具和库来简化开发的过程。
- osgUtil::SceneView——这个类封装了更新，拣选和绘制遍历，但是并不启用DatabasePager。有一部分应用程序会使用 SceneView 作为 OSG 渲 染的主接口。
- Producer和osgProducer——Producer是一个外部的摄像机库，可以支持多通道渲染。osgProducer 是一个集成了Producer和OSG的应用库。Producer有相当多的用户，目前有一部分的OSG程序是基于 Producer和osgProducer开发的。

OSG 2.0 版本的核心库添加了一个新的库成员——osgViewer库。osgViewer包含了一系列用于控制视口显示的相关的类，并封装了大量用户常用的功能函 数，例如显示管理，事件响应，场景渲染等。这个库使用 osg::Camera 类来管理 OpenGL 的模型-视图矩阵。与 SceneView 类不同，osgViewer 库的视口类提供了 对 DatabasePager 的全部支持。osgViewer还可以针对同一个场景图形，提供并通过多个独立的视口显示该场景。